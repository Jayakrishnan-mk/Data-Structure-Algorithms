// O(n²) - QUADRATIC TIME COMPLEXITY
// O(log n) - LOGARITHMIC TIME COMPLEXITY

// MERGE SORT = TC - O(n log n)
//       = DIVIDE AND CONQUER ALGORITHM
//       = SPLITTING THE ARRAY VALUES WITH RECURSION AND SORTING ARRAY AND MERGING THE VALUES
// QUICK SORT = TC - O(n log n)- average case. worst case- O(n²)
//       = DIVIDE AND CONQUER ALGORITHM
//       = SELECTING A PIVOT ELEMENT AND PARTITIONING THE ARRAY TO SUB ARRAYS
//       = ELEMENTS SMALLER THAN THE PIVOT TO THE LEFT
//       = AND ELEMENTS HIGHER THAN THE PIVOT TO THE RIGHT
//       = THEN IT RECURSIVELY SORT THE ARRAYS
// HASH TABLE / HASH MAP = TC - O(1)-average or O(n)-worst case
//       = KEY-VALUE PAIR DATA STRUCTURE
//       = FASTEST WAY TO ACCESS DATA USING KEY
//       = IDEAL HASH FUNCTION SHOULD HAVE MINIMUM COLLISION
//       = COLLISION HAPPENS WHEN TWO KEYS MAP TO SAME INDEX
//       = COMMON RESOLUTION TECHNIQUES:
//           1. SEPARATE CHAINING → STORE MULTIPLE VALUES IN SAME INDEX (USING LINKED LIST/ARRAY)
//           2. LINEAR PROBING → FIND NEXT EMPTY INDEX IF COLLISION OCCURS
//       = HASH TABLE IS USED IN:
//           - CACHING SYSTEMS
//           - DATABASE INDEXING
//           - OBJECT LOOKUP IN JS

// SINGLY LINKED LIST = TC - O
//    = IS AN EXCELLENT ALTERNATIVE TO ARRAY-WHEN INSERTION AND DELETION AT THE BEGINNING ARE FREQUENTLY REQUIRED.
//    = LINKED LIST HAS NO INDEX CONTAINS LIKE ARRAYS.
// DOUBLY LINKED LIST = TC -
//    = INSERTION - O(1)
//    = REMOVAL - O(1)
//    = SEARCHING - O(N) - (O(N/2) actually)
//    = ACCESS - O(N)

// BINARY SEARCH = TC - O(log n)
//      = INSTEAD OF ELIMINATING ONE ITEM AT A TIME, WE CAN ELIMINATE HALF OF THE ARRAY ITEMS AT A TIME
//      = BEST COMPARE B/W LINEAR SEARCH,
//      = ONLY APPLICABLE IF ARRAY IS SORTED
//      = DIVIDE AND CONQUER ALGORITHM
// LINEAR SEARCH = TC - O(n)
//      = CHECKING EACH ELEMENT ONE BY ONE.

// BUBBLE SORT = TC - O(n²)
//       = FIRST PLACING LARGE VALUES TO THE END OF THE ARRAY WITH SWAPPING EACH ITEM
// SELECTION SORT = TC - O(n²)
//       = FIRST PLACING SMALL VALUES TO THE STARTING OF THE ARRAY AND SWAPPING AT THE END OF THE LOOP
//       = REDUCING THE NO. OF SWAPS COMPARE B/W BUBBLE SORT
// INSERTION SORT = TC - O(n²)
//       = START WITH THE SECOND ELEMENT AND COMPARE IT WITH THE PREVIOUS ELEMENTS.


// FOR THE STACK AND QUEUE
// INSERTION AND REMOVAL IS CONSTANT(o(1)). THAT'S THE USE OF THESE.

// STACK =  LIFO METHOD
//      MAINLY USED FOR : MANAGING FUNCTION INVOCATION
//                        UNDO/REDO
//                        ROUTING (THE HISTORY OBJECT) TREATING LIKE A STACK (PAGE HISTORY - BACK/FORWARD IN WEBSITES)
//      TC = INSERTION AND REMOVAL - O(1)
//           SEARCHING AND ACCESS - O(N)
// QUEUE =  FIFO METHOD
//      MAINLY USED FOR : BACKGROUND TASKS
//                        PRINTING / TASK PROCESSING
//                        UPLOADING RESOURCES
//          INSERTION - O(1)
//          REMOVAL = O(1)
//          SEARCHING = O(N)
//          ACCESSING = O(N)